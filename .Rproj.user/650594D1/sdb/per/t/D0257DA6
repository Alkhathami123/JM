{
    "contents" : "residuals.jointModel <-\nfunction (object, process = c(\"Longitudinal\", \"Event\"), \n    type = c(\"Marginal\", \"Subject\", \"stand-Marginal\", \"stand-Subject\", \n        \"Martingale\", \"nullMartingale\", \"CoxSnell\", \"AFT\"), MI = FALSE, \n    M = 50, time.points = NULL, return.data = FALSE, ...) {\n    if (!inherits(object, \"jointModel\"))\n        stop(\"Use only with 'jointModel' objects.\\n\")\n    process <- match.arg(process)\n    type <- match.arg(type)\n    if (process == \"Longitudinal\") {\n        # Observed data\n        y <- object$y$y\n        X <- object$x$X\n        Z <- object$x$Z\n        ncx <- ncol(X)\n        ncz <- ncol(Z)\n        id <- object$id\n        # Fitted Values\n        fitted.vals <- if (type == \"Marginal\" || type == \"stand-Marginal\") {\n            as.vector(X %*% object$coefficients$betas)\n        } else {\n            as.vector(X %*% object$coefficients$betas + object$EB$Zb)\n        }\n        # Residuals\n        resid.vals <- if (type == \"Marginal\" || type == \"Subject\") {\n            as.vector(y - fitted.vals)\n        } else if (type == \"stand-Subject\"){\n            as.vector(y - fitted.vals) / object$coefficients$sigma\n        } else {\n            D <- object$coefficients$D\n            if (nrow(D) != ncol(D))\n                D <- diag(c(D))\n            unlist(lapply(split(cbind(Z, as.vector(y - fitted.vals)), id), function (x) {\n                M <- matrix(x, ncol = ncz + 1)\n                z <- M[, - (ncz + 1), drop = FALSE]\n                res <- M[, ncz + 1]\n                out <- z %*% D %*% t(z)\n                diag(out) <- diag(out) + object$coefficients$sigma^2\n                solve(chol(out)) %*% res\n            }))\n        }\n        if (!MI) {\n            names(resid.vals) <- names(y)\n            resid.vals\n        } else {\n            if (object$CompRisk)\n                stop(\"residuals() with 'MI = TRUE' is not currently implemented for \",\n                    \"competing risks joint models.\\n\")\n            logT <- object$y$logT\n            d <- object$y$d\n            Xtime <- object$x$Xtime\n            Ztime <- object$x$Ztime\n            Xtime.deriv <- object$x$Xtime.deriv\n            Ztime.deriv <- object$x$Ztime.deriv            \n            Xs <- object$x$Xs\n            Zs <- object$x$Zs\n            Xs.deriv <- object$x$Xs.deriv\n            Zs.deriv <- object$x$Zs.deriv\n            WintF.vl <- object$x$WintF.vl\n            WintF.sl <- object$x$WintF.sl\n            Ws.intF.vl <- object$x$Ws.intF.vl\n            Ws.intF.sl <- object$x$Ws.intF.sl\n            P <- object$x$P\n            wk <- object$x$wk\n            method <- object$method\n            parameterization <- object$parameterization\n            LongFormat <- object$LongFormat\n            idT <- object$x$idT\n            W1 <- object$x$W\n            WW <- if (method == \"Cox-PH-GH\") {\n                stop(\"multiple-imputation-based residuals are not available \", \n                    \"for joint models with method = 'Cox-PH-GH'.\\n\")\n            } else if (method == \"piecewise-PH-GH\") {\n                ind.D <- object$y$ind.D\n                nk <- object$control$GKk\n                st <- object$x$st\n                ind.K <- rep(unlist(lapply(ind.D, seq_len)), each = nk)\n                wk <- unlist(lapply(ind.D, function (n) rep(object$x$wk, n)))\n                wkP <- wk * rep(object$x$P, each = nk)\n                W1\n            } else if (method == \"weibull-PH-GH\" || method == \"weibull-AFT-GH\") {\n                log.st <- log(object$x$st)\n                if (is.null(W1)) as.matrix(rep(1, length(logT))) else cbind(1, W1)\n            } else if (method == \"spline-PH-GH\") {\n                W2 <- object$x$W2\n                W2s <- object$x$W2s\n                W1\n            } else {\n                W2 <- splineDesign(object$knots, logT, ord = object$control$ord)\n                nk <- ncol(W2) \n                if (is.null(W1)) W2 else cbind(W2, W1)\n            }\n            ncww <- if (is.null(WW)) 0 else ncol(WW)\n            n <- length(logT)\n            ni <- as.vector(tapply(id, id, length))\n            obs.times <- if (!object$timeVar %in% names(object$data)) {\n                if (is.null(ot <- attr(time.points, \"obs.times\")))\n                    stop(\"could not extract observed times from either the design \", \n                        \"matrix for the longitudinal measurements or\\n\\tthe 'time.points' argument.\\n\")\n                else\n                    ot\n            } else { \n                object$data[[object$timeVar]]\n            }\n            environment(MI.fixed.times) <- environment(MI.random.times) <- environment()\n            if (inherits(time.points, \"weibull.frailty\")) {\n                MI.random.times(time.points)\n            } else {\n                MI.fixed.times(time.points)\n            }\n        }\n    } else {\n        #fits <- fitted(object, process = \"Event\", type = \"Subject\", scale = \"cumulative-Hazard\")\n        #events <- object$y$d\n        fits <- cumHaz(object, type == \"nullMartingale\")\n        ni <- tapply(object$id, object$id, length)\n        events <- rep(object$y$d, ni)\n        events <- ave(events, object$id, FUN = function (x) c(rep(0, length(x)-1), x[1]))\n        if (type == \"AFT\") {\n            if (object$method == \"weibull-AFT-GH\") {\n                fitted(object, process = \"Event\", type = \"Subject\", scale = \"log-cumulative-Hazard\")\n            } else {\n                warning(\"AFT residuals are only calculated for the Weibull AFT model; \",\n                    \"martingale residuals are calculated instead.\\n\")\n                events - fits\n            }\n        } else if (type == \"CoxSnell\") {\n            if (object$method %in% c(\"weibull-PH-GH\", \"weibull-AFT-GH\", \n                \"piecewise-PH-GH\", \"spline-PH-GH\", \"ch-Laplace\")) {\n                fitted(object, process = \"Event\", type = \"Subject\", scale = \"cumulative-Hazard\")\n            } else {\n                warning(\"CoxSnell residuals are only calculated for the parametric survival \",\n                    \"models; martingale residuals are calculated instead.\\n\")\n                events - fits                \n            }\n        } else {\n            events - fits\n        }\n    }\n}\n",
    "created" : 1456994349450.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3033715790",
    "id" : "D0257DA6",
    "lastKnownWriteTime" : 1435044061,
    "path" : "C:/Users/Dimitris/Documents/PackagesGitHub/JM/R/residuals.jointModel.R",
    "project_path" : "R/residuals.jointModel.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}