{
    "contents" : "log.posterior.b2 <-\nfunction (object) {\n    method <- object$method\n    timeVar <- object$timeVar\n    interFact <- object$interFact\n    parameterization <- object$parameterization\n    derivForm <- object$derivForm\n    indFixed <- derivForm$indFixed\n    indRandom <- derivForm$indRandom\n    n <- object$n\n    id <- object$id\n    idT <- object$x$idT\n    y <- object$y$y\n    ind.D <- object$y$ind.D\n    logT <- object$y$logT\n    d <- object$y$d\n    strt <- object$y$strata\n    X <- object$x$X\n    Xs <- object$x$Xs\n    Xs.deriv <- object$x$Xs.deriv\n    Xtime <- object$x$Xtime\n    Xtime.deriv <- object$x$Xtime.deriv\n    Z <- object$x$Z\n    Zs <- object$x$Zs\n    Zs.deriv <- object$x$Zs.deriv\n    Ztime <- object$x$Ztime\n    Ztime.deriv <- object$x$Ztime.deriv\n    W <- object$x$W\n    W2 <- object$x$W2\n    W2s <- object$x$W2s\n    WintF.vl <- object$x$WintF.vl\n    Ws.intF.vl <- object$x$Ws.intF.vl\n    WintF.sl <- object$x$WintF.sl\n    Ws.intF.sl <- object$x$Ws.intF.sl\n    ####\n    P <- object$x$P\n    st <- object$x$st\n    wk <- object$x$wk\n    id.GK <- object$x$id.GK\n    if (is.null(id.GK))\n        id.GK <- rep(seq_along(logT), each = object$control$GKk)\n    Q <- object$x$Q\n    ncx <- ncol(X)\n    ncz <- ncol(Z)\n    ncww <- ncol(W)\n    lag <- object$y$lag\n    betas <- object$coefficients$betas\n    sigma <- object$coefficients$sigma\n    D <- object$coefficients$D\n    diag.D <- ncol(D) == 1 & nrow(D) > 1\n    D <- if (diag.D) diag(c(D)) else D\n    gammas <- object$coefficients$gammas\n    alpha <- object$coefficients$alpha\n    Dalpha <- object$coefficients$Dalpha\n    sigma.t <- object$coefficients$sigma.t\n    xi <- object$coefficients$xi\n    gammas.bs <- object$coefficients$gammas.bs\n    ####\n    ff <- function (b, i) {\n        id.i <- id %in% i\n        idT.i <- idT %in% i\n        id.GK.i <- id.GK %in% which(idT.i)\n        X.i <- X[id.i, , drop = FALSE]\n        Z.i <- Z[id.i, , drop = FALSE]\n        mu.y <- as.vector(X.i %*% betas) + rowSums(Z.i * rep(b, each = nrow(Z.i)))\n        logNorm <- dnorm(y[id.i], mu.y, sigma, TRUE)\n        log.p.yb <- sum(logNorm)\n        log.p.b <- dmvnorm(b, rep(0, ncz), D, TRUE)\n        eta.tw <- if (!is.null(W)) {\n            if (method %in% c(\"weibull-PH-GH\", \"weibull-AFT-GH\"))\n                as.vector(cbind(1, W[idT.i, , drop = FALSE]) %*% gammas)\n            else\n                as.vector(W[idT.i, , drop = FALSE] %*% gammas)\n        } else {\n            0\n        }\n        if (parameterization %in% c(\"value\", \"both\")) {\n            Xtime.i <- Xtime[idT.i, , drop = FALSE]\n            Ztime.i <- Ztime[idT.i, , drop = FALSE]\n            Y <- c(Xtime.i %*% betas) + rowSums(Ztime.i * rep(b, each = nrow(Ztime.i)))\n            Xs.i <- Xs[id.GK.i, , drop = FALSE]\n            Zs.i <- Zs[id.GK.i, , drop = FALSE]\n            Ys <- as.vector(Xs.i %*% betas + rowSums(Zs.i * rep(b, each = nrow(Zs.i))))\n            WintF.vl.i <- WintF.vl[idT.i, , drop = FALSE]\n            Ws.intF.vl.i <- Ws.intF.vl[id.GK.i, , drop = FALSE]\n        }\n        if (parameterization %in% c(\"slope\", \"both\")) {\n            Xtime.deriv.i <- Xtime.deriv[idT.i, , drop = FALSE]\n            Ztime.deriv.i <- Ztime.deriv[idT.i, , drop = FALSE]\n            Y.deriv <- c(Xtime.deriv.i %*% betas[indFixed]) + \n                rowSums(Ztime.deriv.i * rep(b[indRandom], each = nrow(Ztime.deriv.i)))\n            Xs.deriv.i <- Xs.deriv[id.GK.i, , drop = FALSE]\n            Zs.deriv.i <- Zs.deriv[id.GK.i, , drop = FALSE]\n            Ys.deriv <- as.vector(Xs.deriv.i %*% betas[indFixed]) + \n                rowSums(Zs.deriv.i * rep(b[indRandom], each = nrow(Zs.deriv.i)))\n            WintF.sl.i <- WintF.sl[idT.i, , drop = FALSE]\n            Ws.intF.sl.i <- Ws.intF.sl[id.GK.i, , drop = FALSE]\n        }\n        tt <- switch(parameterization,\n            \"value\" = c(WintF.vl.i %*% alpha) * Y, \n            \"slope\" = c(WintF.sl.i %*% Dalpha) * Y.deriv,\n            \"both\" = c(WintF.vl.i %*% alpha) * Y + \n                c(WintF.sl.i %*% Dalpha) * Y.deriv)\n        ss <- switch(parameterization,\n            \"value\" = c(Ws.intF.vl.i %*% alpha) * Ys, \n            \"slope\" = c(Ws.intF.sl.i %*% Dalpha) * Ys.deriv,\n            \"both\" = c(Ws.intF.vl.i %*% alpha) * Ys + \n                c(Ws.intF.sl.i %*% Dalpha) * Ys.deriv)\n        ###\n        log.p.tb <- if (method == \"weibull-PH-GH\") {\n            st.i <- st[id.GK.i]\n            Vi <- exp(log(sigma.t) + (sigma.t - 1) * log(st.i) + ss)\n            log.S <- - exp(eta.tw) * P[i] * sum(wk * Vi)\n            log.h <- log(sigma.t) + (sigma.t - 1) * logT[i] + eta.tw + tt\n            d[i] * log.h + log.S\n        } else if (method == \"weibull-AFT-GH\") {\n            Vi <- exp(eta.tw) * P[i] * sum(wk * exp(ss))\n            log.S <- - Vi^sigma.t\n            log.h <- log(sigma.t) + (sigma.t - 1) * log(Vi) + eta.tw + tt\n            d[i] * log.h + log.S\n        } else if (method == \"spline-PH-GH\") {\n            W2.i <- W2[idT.i, , drop = FALSE]\n            W2s.i <- W2s[id.GK.i, , drop = FALSE]\n            Vi <- exp(c(W2s.i %*% gammas.bs) + ss)\n            kk.i <- sum(idT.i)\n            log.S <- - exp(eta.tw) * P[idT.i] * \n                tapply(rep(wk, kk.i) * Vi, \n                    rep(seq_len(kk.i), each = length(wk)), sum)\n            log.h <- eta.tw + tt + c(W2.i %*% gammas.bs) \n            sum(d[idT.i] * log.h + log.S)\n        } else if (method == \"piecewise-PH-GH\") {\n            nk <- object$control$GKk\n            wkP <- rep(wk, sum(id.GK.i)/nk) * rep(P, each = nk)[id.GK.i]\n            log.S <- - exp(eta.tw) * sum(xi[ind.D[i]] * wkP * exp(ss))\n            log.h <- log(xi[ind.D[i]]) + eta.tw + tt\n            as.vector(d[i] * log.h + log.S)\n        }\n        -(log.p.yb + log.p.tb + log.p.b)\n    }\n    modes <- ranef(object)\n    hessians <- vector(\"list\", n)\n    for (i in seq_len(n)) {\n        opt <- optim(modes[i, ], ff, i = i, method = \"BFGS\", hessian = TRUE)\n        modes[i, ] <- opt$par\n        hessians[[i]] <- solve(opt$hessian)\n    }\n    rownames(modes) <- if (!object$CompRisk && !object$LongFormat) {\n        names(object$y$logT)\n    } else {\n        seq_len(nrow(modes))\n    }\n    names(hessians) <- rownames(modes)\n    list(modes = modes, vars = hessians)\n}\n",
    "created" : 1451330330635.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3376071248",
    "id" : "F461245",
    "lastKnownWriteTime" : 1451330524,
    "path" : "C:/Users/Dimitris/Documents/PackagesGitHub/JM/R/log.posterior.b2.R",
    "project_path" : "R/log.posterior.b2.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}