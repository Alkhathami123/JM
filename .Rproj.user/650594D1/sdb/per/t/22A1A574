{
    "contents" : "phGH.fit <-\nfunction (x, y, id, initial.values, parameterization, derivForm, control) {\n    # response vectors\n    logT <- as.vector(y$logT)\n    d <- as.vector(y$d)\n    y <- as.vector(y$y)\n    # design matrices\n    X <- x$X\n    Xtime <- x$Xtime\n    Xtime2 <- x$Xtime2\n    Z <- x$Z\n    Ztime <- x$Ztime\n    Ztime2 <- x$Ztime2\n    WW <- x$W\n    WintF.vl <- x$WintF.vl\n    WintF.sl <- x$WintF.sl\n    Ws.intF.vl <- x$Ws.intF.vl\n    Ws.intF.sl <- x$Ws.intF.sl\n    dimnames(X) <- dimnames(Xtime) <- dimnames(Xtime2) <- NULL\n    dimnames(Z) <- dimnames(Ztime) <- dimnames(Ztime2) <- dimnames(WW) <- NULL\n    attr(X, \"assign\") <- attr(X, \"contrasts\") <- NULL\n    attr(Xtime, \"assign\") <- attr(Xtime, \"contrasts\") <- NULL\n    attr(Xtime2, \"assign\") <- attr(Xtime2, \"contrasts\") <- NULL    \n    attr(Z, \"assign\") <- attr(Ztime, \"assign\") <- NULL\n    WintF.vl <- dropAttr(WintF.vl); WintF.sl <- dropAttr(WintF.sl)\n    Ws.intF.vl <- dropAttr(Ws.intF.vl); Ws.intF.sl <- dropAttr(Ws.intF.sl)\n    # sample size settings\n    ncx <- ncol(X)\n    ncz <- ncol(Z)\n    ncww <- if (is.null(WW)) 0 else ncol(WW)\n    n <- length(logT)\n    N <- length(y)\n    ni <- as.vector(tapply(id, id, length))\n    # crossproducts and others\n    XtX <- crossprod(X)\n    ZtZ <- lapply(split(Z, id), function (x) crossprod(matrix(x, ncol = ncz)))\n    names(ZtZ) <- NULL\n    ZtZ <- matrix(unlist(ZtZ), n, ncz * ncz, TRUE)\n    outer.Ztime <- lapply(1:n, function (x) Ztime[x, ] %o% Ztime[x, ])\n    Time <- exp(logT)\n    unqT <- sort(unique(Time[d == 1]))\n    indT <- x$indT\n    unq.indT <- unique(indT)\n    nk <- as.vector(sapply(split(indT, indT), length))\n    ind.L1 <- unlist(lapply(nk, seq, from = 1))\n    ind.L2 <- colSums(d * outer(Time, unqT, \"==\"))\n    ind.T0 <- match(Time, unqT)\n    # Gauss-Hermite quadrature rule components\n    GH <- gauher(control$GHk)\n    b <- as.matrix(expand.grid(rep(list(GH$x), ncz)))\n    k <- nrow(b)\n    wGH <- as.matrix(expand.grid(rep(list(GH$w), ncz)))    \n    wGH <- 2^(ncz/2) * apply(wGH, 1, prod) * exp(rowSums(b * b))\n    if (control$typeGH == \"simple\") {\n        b <- sqrt(2) * t(control$inv.chol.VC %*% t(b))\n        wGH <- wGH * control$det.inv.chol.VC\n    } else { \n        b <- sqrt(2) * b\n       VCdets <- control$det.inv.chol.VCs\n    }\n    dimnames(b) <- NULL\n    b2 <- if (ncz == 1) b * b else t(apply(b, 1, function (x) x %o% x))\n    Ztb <- Z %*% t(b)\n    Ztime.b <- Ztime %*% t(b)\n    Ztime2.b <- Ztime2 %*% t(b)\n    # pseudo-adaptive Gauss-Hermite\n    if (control$typeGH != \"simple\") {\n        lis.b <- vector(\"list\", n)\n        for (i in 1:n)\n            lis.b[[i]] <- t(control$inv.chol.VCs[[i]] %*% t(b)) + \n                rep(control$ranef[i, ], each = k)\n        lis.b2 <- lapply(lis.b, function (b) if (ncz == 1) b * b else\n            t(apply(b, 1, function (x) x %o% x)))\n        for (i in 1:n) {\n            Ztb[id == i, ] <- Z[id == i, , drop = FALSE] %*% t(lis.b[[i]])\n            Ztime.b[i, ] <- Ztime[i, , drop = FALSE] %*% t(lis.b[[i]])\n            Ztime2.b[i, ] <- Ztime2[i, , drop = FALSE] %*% t(lis.b[[i]])\n        }\n    }\n    # initial values\n    betas <- as.vector(initial.values$betas)\n    sigma <- initial.values$sigma\n    gammas <- as.vector(initial.values$gammas)\n    alpha <- as.vector(initial.values$alpha)\n    lambda0 <- initial.values$lambda0\n    D <- initial.values$D\n    diag.D <- !is.matrix(D)\n    if (!diag.D) dimnames(D) <- NULL else names(D) <- NULL\n    # fix environments for functions\n    environment(opt.survPH) <- environment(gr.survPH) <- environment(gr.longPH) <- environment()\n    environment(LogLik.phGH) <- environment(Score.phGH) <- environment()\n    old <- options(warn = (-1))\n    on.exit(options(old))\n    # EM iterations\n    iter <- control$iter.EM\n    Y.mat <- matrix(0, iter + 1, ncx + 1)\n    T.mat <- matrix(0, iter + 1, ncww + 1)\n    B.mat <- if (diag.D) matrix(0, iter + 1, ncz) else matrix(0, iter + 1, ncz * ncz)\n    lgLik <- numeric(iter + 1)\n    conv <- TRUE\n    for (it in 1:iter) {\n        # save parameter values in matrix\n        Y.mat[it, ] <- c(betas, sigma)\n        T.mat[it, ] <- c(gammas, alpha)\n        B.mat[it,] <- D\n        \n        # linear predictors\n        eta.yx <- as.vector(X %*% betas)\n        eta.yxT <- as.vector(Xtime %*% betas)\n        eta.yxT2 <- as.vector(Xtime2 %*% betas)\n        Y <- eta.yxT + Ztime.b\n        Y2 <- eta.yxT2 + Ztime2.b\n        eta.tw <- if (!is.null(WW)) as.vector(WW %*% gammas) else rep(0, n)\n        eta.t <- eta.tw + alpha * Y\n        eta.s <- alpha * Y2\n        exp.eta.s <- exp(eta.s)\n         \n        # E-step\n        mu.y <- eta.yx + Ztb\n        logNorm <- dnorm(y, mu.y, sigma, TRUE)\n        log.p.yb <- rowsum(logNorm, id); dimnames(log.p.yb) <- NULL\n        log.lambda0T <- log(lambda0[ind.T0])\n        log.lambda0T[is.na(log.lambda0T)] <- 0\n        log.hazard <- log.lambda0T + eta.t\n        S <- matrix(0, n, k)\n        S[unq.indT, ] <- rowsum(lambda0[ind.L1] * exp.eta.s, indT, reorder = FALSE); dimnames(S) <- NULL\n        log.survival <- - exp(eta.tw) * S\n        log.p.tb <- d * log.hazard + log.survival\n        log.p.b <- if (control$typeGH == \"simple\") {\n            rep(dmvnorm(b, rep(0, ncz), D, TRUE), each = n)\n        } else {\n            matrix(dmvnorm(do.call(rbind, lis.b), rep(0, ncz), D, TRUE), n, k, byrow = TRUE)\n        }\n        p.ytb <- exp(log.p.yb + log.p.tb + log.p.b)\n        if (control$typeGH != \"simple\")\n            p.ytb <- p.ytb * VCdets\n        p.yt <- c(p.ytb %*% wGH)\n        p.byt <- p.ytb / p.yt\n        post.b <- if (control$typeGH == \"simple\") {\n            p.byt %*% (b * wGH)\n        } else {\n            sapply(seq_len(ncz), function (i)\n                (p.byt * t(sapply(lis.b, \"[\", seq_len(k), i))) %*% wGH)\n        }\n        post.vb <- if (control$typeGH == \"simple\") { \n            if (ncz == 1) {\n                c(p.byt %*% (b2 * wGH)) - c(post.b * post.b)\n            } else {\n                (p.byt %*% (b2 * wGH)) - t(apply(post.b, 1, function (x) x %o% x))\n            }\n        } else {\n            dd <- sapply(seq_len(ncz^2), function (i)\n                (p.byt * t(sapply(lis.b2, \"[\", seq_len(k), i))) %*% wGH)\n            bb <- apply(post.b, 1, function (x) x %o% x)\n            dd - if (ncz == 1) c(bb) else t(bb)\n        }\n        \n        # compute log-likelihood\n        log.p.yt <- log(p.yt)\n        lgLik[it] <- sum(log.p.yt[is.finite(log.p.yt)], na.rm = TRUE)\n                \n        # print results if verbose\n        if (control$verbose) {\n            cat(\"\\n\\niter:\", it, \"\\n\")\n            cat(\"log-likelihood:\", lgLik[it], \"\\n\")\n            cat(\"betas:\", round(betas, 4), \"\\n\")\n            cat(\"sigma:\", round(sigma, 4), \"\\n\")\n            if (!is.null(WW))\n                cat(\"gammas:\", round(gammas, 4), \"\\n\")\n            cat(\"alpha:\", round(alpha, 4), \"\\n\")\n            cat(\"D:\", if (!diag.D) round(D[lower.tri(D, TRUE)], 4) else round(D, 4), \"\\n\")\n        }\n        \n        # check convergence\n        if (it > 5) {\n            if (lgLik[it] > lgLik[it - 1]) {\n                thets1 <- c(Y.mat[it - 1, ], T.mat[it - 1, ], B.mat[it - 1, ])\n                thets2 <- c(Y.mat[it, ], T.mat[it, ], B.mat[it, ])\n                check1 <- max(abs(thets2 - thets1) / (abs(thets1) + control$tol1)) < control$tol2\n                check2 <- (lgLik[it] - lgLik[it - 1]) < control$tol3 * (abs(lgLik[it - 1]) + control$tol3)\n                if (check1 || check2) {\n                    conv <- FALSE\n                    if (control$verbose)\n                        cat(\"\\n\\nconverged!\\n\")\n                    break\n                }\n            } else {\n                lambda0 <- lambda0.old\n                log.lambda0T <- log(lambda0[ind.T0])\n                log.lambda0T[is.na(log.lambda0T)] <- 0\n                log.hazard <- log.lambda0T + eta.t\n                S <- matrix(0, n, k)\n                S[unq.indT, ] <- rowsum(lambda0[ind.L1] * exp.eta.s, indT, reorder = FALSE)\n                log.survival <- - exp(eta.tw) * S\n                log.p.tb <- d * log.hazard + log.survival\n                p.ytb <- exp(log.p.yb + log.p.tb + log.p.b)\n                p.yt <- c(p.ytb %*% wGH)\n                p.byt <- p.ytb / p.yt\n                post.b <- p.byt %*% (b * wGH)\n                post.vb <- if (ncz == 1) {\n                    c(p.byt %*% (b2 * wGH)) - c(post.b * post.b)\n                } else {\n                    (p.byt %*% (b2 * wGH)) - t(apply(post.b, 1, function (x) x %o% x))\n                }\n                log.p.yt <- log(p.yt)\n                lgLik[it] <- sum(log.p.yt[is.finite(log.p.yt)], na.rm = TRUE)\n                if (control$verbose) {\n                    cat(\"\\n\\niter:\", it, \"\\n\")\n                    cat(\"log-likelihood:\", lgLik[it], \"\\n\")\n                    cat(\"betas:\", round(betas, 4), \"\\n\")\n                    cat(\"sigma:\", round(sigma, 4), \"\\n\")\n                    if (!is.null(WW))\n                        cat(\"gammas:\", round(gammas, 4), \"\\n\")\n                    cat(\"alpha:\", round(alpha, 4), \"\\n\")\n                    cat(\"D:\", if (!diag.D) round(D[lower.tri(D, TRUE)], 4) else round(D, 4), \"\\n\")\n                }\n            }\n        }\n        if (iter == 0) break\n               \n        # M-step\n        if (it > 2) {\n            Zb <- rowSums(Z * post.b[id, ], na.rm = TRUE)\n            mu <- y - eta.yx\n            tr.tZZvarb <- sum(ZtZ * post.vb, na.rm = TRUE)\n            sigman <- sqrt(c(crossprod(mu, mu - 2 * Zb) + crossprod(Zb) + tr.tZZvarb) / N)\n            Dn <- if (control$typeGH == \"simple\") {\n                matrix(colMeans(p.byt %*% (b2 * wGH), na.rm = TRUE), ncz, ncz)\n            } else {\n                matrix(colMeans(dd, na.rm = TRUE), ncz, ncz)\n            }\n            Dn <- if (diag.D) diag(Dn) else 0.5 * (Dn + t(Dn))\n            Hbetas <- nearPD(fd.vec(betas, gr.longPH))\n            scbetas <- gr.longPH(betas)\n            betasn <- betas - c(solve(Hbetas, scbetas))\n            thetas <- c(gammas, alpha)\n            Hthetas <- nearPD(fd.vec(thetas, gr.survPH))\n            scthetas <- gr.survPH(thetas)\n            thetasn <- thetas - c(solve(Hthetas, scthetas))\n        }\n        ee <- c((exp.eta.s * exp(eta.tw[indT]) * p.byt[indT, ]) %*% wGH)\n        lambda0n <- ind.L2 / as.vector(tapply(ee, ind.L1, sum, na.rm = TRUE))\n        \n        # update parameter values\n        if (it > 2) {\n            betas <- betasn\n            sigma <- sigman\n            D <- Dn\n            gammas <- thetasn[seq_len(ncww)]\n            alpha <- thetasn[ncww + 1]\n        }\n        lambda0.old <- lambda0\n        lambda0 <- lambda0n\n    }\n    thetas <- c(betas, log(sigma), gammas, alpha, if (diag.D) log(D) else chol.transf(D))\n    lgLik <- lgLik[it]\n    # calculate Score vector\n    Score <- Score.phGH(thetas)\n    # calculate Hessian matrix\n    if (control$verbose) cat(\"\\ncalculating Hessian...\\n\")\n    Hessian <- if (control$numeriDeriv == \"fd\") {\n        fd.vec(thetas, Score.phGH, eps = control$eps.Hes)\n    } else { \n        cd.vec(thetas, Score.phGH, eps = control$eps.Hes)\n    }\n    names(betas) <- names(initial.values$betas)\n    if (!diag.D) dimnames(D) <- dimnames(initial.values$D) else names(D) <- names(initial.values$D)\n    names(gammas) <- colnames(x$W)\n    nams <- c(paste(\"Y.\", c(names(betas), \"sigma\"), sep = \"\"), paste(\"T.\", c(names(gammas), \"alpha\"), sep = \"\"),\n        paste(\"B.\", if (!diag.D) paste(\"D\", seq(1, ncz * (ncz + 1) / 2), sep = \"\") else names(D), sep = \"\"))\n    dimnames(Hessian) <- list(nams, nams)\n    colnames(post.b) <- colnames(x$Z)\n    list(coefficients = list(betas = betas, sigma = sigma, gammas = gammas, alpha = alpha, \n        lambda0 = cbind(\"basehaz\" = lambda0, \"time\" = unqT), D = as.matrix(D)), Score = Score, Hessian = Hessian, \n        logLik = lgLik, EB = list(post.b = post.b, post.vb = post.vb, \n                                  Zb = if (iter == 0) rowSums(Z * post.b[id, ], na.rm = TRUE) else Zb, \n        Ztimeb = rowSums(Ztime * post.b), Ztime2b = rowSums(Ztime2 * post.b[indT, ])), \n        indexes = list(indT = indT, ind.L1 = ind.L1), iters = it, convergence = conv, \n        n = n, N = N, ni = ni, d = d, id = id)\n}\n",
    "created" : 1458808030060.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2136098900",
    "id" : "22A1A574",
    "lastKnownWriteTime" : 1458808312,
    "path" : "C:/Users/Dimitris/Documents/PackagesGitHub/JM/R/phGH.fit.R",
    "project_path" : "R/phGH.fit.R",
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "type" : "r_source"
}