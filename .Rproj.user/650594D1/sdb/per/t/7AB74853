{
    "contents" : "jointModel <- function (lmeObject, survObject, timeVar, parameterization = c(\"value\", \"slope\", \"both\"), \n        method = c(\"weibull-PH-aGH\", \"weibull-PH-GH\", \"weibull-AFT-aGH\", \"weibull-AFT-GH\", \n        \"piecewise-PH-aGH\", \"piecewise-PH-GH\", \"Cox-PH-aGH\", \"Cox-PH-GH\", \"spline-PH-aGH\", \n        \"spline-PH-GH\", \"ch-Laplace\"), interFact = NULL, derivForm = NULL, lag = 0, \n        scaleWB = NULL, CompRisk = FALSE, init = NULL, control = list(), ...) {\n    cl <- match.call()\n    if (!inherits(lmeObject, \"lme\"))\n        stop(\"\\n'lmeObject' must inherit from class lme.\")\n    if (length(lmeObject$group) > 1)\n        stop(\"\\nnested random-effects are not allowed in lme().\")\n    if (!is.null(lmeObject$modelStruct$corStruct))\n        warning(\"correlation structure in 'lmeObject' is ignored.\\n\")\n    if (!is.null(lmeObject$modelStruct$varStruct))\n        warning(\"variance structure in 'lmeObject' is ignored.\\n\")        \n    if (!inherits(survObject, \"coxph\") && !inherits(survObject, \"survreg\"))\n        stop(\"\\n'survObject' must inherit from class coxph or class survreg.\")\n    if (!is.matrix(survObject$x))\n        stop(\"\\nuse argument 'x = TRUE' in \", \n            if (inherits(survObject, \"coxph\")) \"'coxph()'.\" else \"'survreg()'.\")\n    if (length(timeVar) != 1 || !is.character(timeVar))\n        stop(\"\\n'timeVar' must be a character string.\")\n    method. <- match.arg(method)\n    method <- switch(method., \"weibull-AFT-GH\" = , \"weibull-AFT-aGH\" = \"weibull-AFT-GH\",\n        \"weibull-PH-GH\" = , \"weibull-PH-aGH\" = \"weibull-PH-GH\", \n        \"piecewise-PH-GH\" = , \"piecewise-PH-aGH\" = \"piecewise-PH-GH\",\n        \"Cox-PH-GH\" = , \"Cox-PH-aGH\" = \"Cox-PH-GH\", \"spline-PH-GH\" =, \n        \"spline-PH-aGH\" = \"spline-PH-GH\", \"ch-Laplace\" = \"ch-Laplace\")\n    parameterization <- match.arg(parameterization)\n    if (method == \"Cox-PH-GH\" && !inherits(survObject, \"coxph\"))\n        stop(\"\\nfor 'method = Cox-PH-GH', 'survObject' must inherit from class coxph.\")\n    if (parameterization %in% c(\"slope\", \"both\") && method %in% c(\"Cox-PH-GH\", \"ch-Laplace\"))\n        stop(\"\\nthe slope parameterization is not currently available for methods 'Cox-PH-GH' & 'ch-Laplace'.\")\n    if (parameterization %in% c(\"slope\", \"both\") && is.null(derivForm)) {\n        stop(\"\\nwhen parameterization is 'slope' or 'both' you need to specify the 'derivForm' argument.\")\n    }\n    if (parameterization %in% c(\"slope\", \"both\") && !is.list(derivForm)) {\n        stop(\"\\nthe 'derivForm' argument must be a list with components 'fixed' (a formula),\\n\\t'indFixed'\", \n            \"(a numeric vector), 'random' (a formula) and 'indRandom' (a numeric vector).\")\n    }\n    if (!is.null(interFact) && !is.list(interFact)) {\n        stop(\"\\nthe 'interFact' argument must be a list -- check the help file for more info.\")\n    }\n    if (!is.null(interFact) && method %in% c(\"Cox-PH-GH\", \"ch-Laplace\")) {\n        stop(\"\\nincluding interaction terms is not currently available for methods 'Cox-PH-GH' & 'ch-Laplace'.\")\n    }\n    if (CompRisk && (method != \"spline-PH-GH\" || is.null(survObject$strata))) {\n        stop(\"\\nto fit a competing risks joint model you must choose as method 'spline-PH-GH'\",\n            \" and include a strata() in the specification of the coxph().\")\n    }\n    # survival process\n    formT <- formula(survObject)\n    if (inherits(survObject, \"coxph\")) {\n        W <- survObject$x\n        keepW <- suppressWarnings(!is.na(survObject$coefficients))\n        W <- W[, keepW, drop = FALSE]\n        if (CompRisk) {\n            nRisks <- length(unique(survObject$strata))  \n        } else {\n            nRisks <- 1\n        }\n        surv <- survObject$y\n        if (attr(surv, \"type\") == \"right\") {\n            LongFormat <- FALSE\n            Time <- survObject$y[, 1]\n            d <- survObject$y[, 2]\n        } else if (attr(surv, \"type\") == \"counting\") {\n            LongFormat <- TRUE\n            if (is.null(survObject$model))\n                stop(\"\\nplease refit the Cox model including in the \", \n                    \"call to coxph() the argument 'model = TRUE'.\")\n            Time <- survObject$y[, 2]\n            d <- survObject$y[, 3]\n        }\n        idT <- if (!is.null(survObject$model$cluster)) {\n            as.vector(unclass(survObject$model$cluster))\n        } else {\n            if (!CompRisk) seq_along(Time)\n            else rep(seq_len(length(Time)/nRisks), each = nRisks)\n        }\n        idT <- match(idT, unique(idT))\n    } else {\n        W <- survObject$x[, -1, drop = FALSE]\n        Time <- exp(survObject$y[, 1])\n        d <- survObject$y[, 2]\n        idT <- seq_along(Time)\n        LongFormat <- FALSE\n        nRisks <- 1\n    }\n    nT <- length(unique(idT))\n    if (LongFormat && is.null(survObject$model$cluster))\n        stop(\"\\nuse argument 'model = TRUE' and cluster() in coxph().\")\n    if (!length(W))\n        W <- NULL\n    if (sum(d) < 5)\n        warning(\"\\nmore than 5 events are required.\")\n    WintF.vl <- WintF.sl <- as.matrix(rep(1, length(Time)))\n    if (!is.null(interFact)) {\n        if (!is.null(interFact$value))\n            WintF.vl <- if (is.null(survObject$model)) {\n                model.matrix(interFact$value, data = interFact$data)\n            } else {\n                model.matrix(interFact$value, data = survObject$model)\n            }\n        if (!is.null(interFact$slope))\n            WintF.sl <- if (is.null(survObject$model)) {\n                model.matrix(interFact$slope, data = interFact$data)\n            } else {\n                model.matrix(interFact$slope, data = survObject$model)\n            }\n    }\n    # longitudinal process\n    id <- as.vector(unclass(lmeObject$groups[[1]]))\n    b <- data.matrix(ranef(lmeObject))\n    dimnames(b) <- NULL\n    nY <- nrow(b)\n    if (nY != nT)\n        stop(\"sample sizes in the longitudinal and event processes differ; \", \n            \"maybe you forgot the cluster() argument.\\n\")\n    TermsX <- lmeObject$terms\n    data <- lmeObject$data[all.vars(TermsX)]\n    data <- data[complete.cases(data), ]\n    formYx <- formula(lmeObject)\n    mfX <- model.frame(TermsX, data = data)\n    X <- model.matrix(formYx, mfX)\n    formYz <- formula(lmeObject$modelStruct$reStruct[[1]])    \n    mfZ <- model.frame(terms(formYz), data = data)\n    TermsZ <- attr(mfZ, \"terms\")\n    Z <- model.matrix(formYz, mfZ)\n    y.long <- model.response(mfX, \"numeric\")\n    data.id <- data[!duplicated(id), ]\n    data.id <- data.id[idT, ]\n    if (!timeVar %in% names(data))\n        stop(\"\\n'timeVar' does not correspond to one of the columns in the model.frame of 'lmeObject'.\")\n    # check if there are any longitudinal measurements after the event times\n    max.timeY <- tapply(data[[timeVar]], id, max)\n    max.timeT <- tapply(Time, idT, max)\n    if (!all(max.timeT >= max.timeY)) {\n        idnams <- factor(lmeObject$groups[[1]])\n        stop(\"\\nit seems that there are longitudinal measurements taken after the event times for some subjects \",\n            \"(i.e., check subject(s): \", paste(levels(idnams)[(max.timeT < max.timeY)], collapse = \", \"), \").\")\n    }\n    # extra design matrices for the longitudinal part\n    data.id[[timeVar]] <- pmax(Time - lag, 0)\n    if (parameterization %in% c(\"value\", \"both\")) {\n        mfX.id <- model.frame(TermsX, data = data.id)\n        mfZ.id <- model.frame(TermsZ, data = data.id)\n        Xtime <- model.matrix(formYx, mfX.id)\n        Ztime <- model.matrix(formYz, mfZ.id)\n        long <- c(X %*% fixef(lmeObject)) + rowSums(Z * b[id, ])\n    }\n    if (parameterization %in% c(\"slope\", \"both\")) {\n        mfX.deriv <- model.frame(terms(derivForm$fixed), data = data)\n        TermsX.deriv <- attr(mfX.deriv, \"terms\")\n        mfZ.deriv <- model.frame(terms(derivForm$random), data = data)\n        TermsZ.deriv <- attr(mfZ.deriv, \"terms\")\n        mfX.deriv.id <- model.frame(TermsX.deriv, data = data.id)\n        mfZ.deriv.id <- model.frame(TermsZ.deriv, data = data.id)      \n        Xtime.deriv <- model.matrix(derivForm$fixed, mfX.deriv.id)\n        Ztime.deriv <- model.matrix(derivForm$random, mfZ.deriv.id)\n        Xderiv <- model.matrix(derivForm$fixed, mfX.deriv)\n        Zderiv <- model.matrix(derivForm$random, mfZ.deriv)        \n        long.deriv <- as.vector(c(Xderiv %*% fixef(lmeObject)[derivForm$indFixed]) + \n            if (length(derivForm$indRandom) > 1 || derivForm$indRandom) \n                rowSums(Zderiv * b[id, derivForm$indRandom, drop = FALSE])\n            else\n                rep(0, nrow(Zderiv)))\n    }\n    if (parameterization == \"value\")\n        long.deriv <- NULL\n    if (parameterization == \"slope\")\n        long <- NULL        \n    # response vectors and design matrices\n    y <- list(y = y.long, logT = log(Time), d = d, lag = lag)\n    x <- list(X = X, Z = Z, W = W, WintF.vl = WintF.vl, \n        WintF.sl = WintF.sl, idT = idT, nRisks = nRisks)\n    x <- switch(parameterization, \n        \"value\" = c(x, list(Xtime = Xtime, Ztime = Ztime)),\n        \"slope\" = c(x, list(Xtime.deriv = Xtime.deriv, Ztime.deriv = Ztime.deriv)),\n        \"both\" = c(x, list(Xtime = Xtime, Ztime = Ztime, Xtime.deriv = Xtime.deriv, \n            Ztime.deriv = Ztime.deriv)))\n    # control values\n    ind.noadapt <- method. %in% c(\"weibull-AFT-GH\", \"weibull-PH-GH\", \"piecewise-PH-GH\", \n        \"Cox-PH-GH\", \"spline-PH-GH\")\n    con <- list(only.EM = FALSE, iter.EM = if (method == \"spline-PH-GH\") 120 else 50, \n        iter.qN = 350, optimizer = \"optim\", tol1 = 1e-03, tol2 = 1e-04, \n        tol3 = if (!CompRisk) sqrt(.Machine$double.eps) else 1e-09, numeriDeriv = \"fd\", eps.Hes = 1e-06, \n        parscale = NULL, step.max = 0.1, backtrackSteps = 2, \n        knots = NULL, ObsTimes.knots = TRUE,\n        lng.in.kn = if (method == \"piecewise-PH-GH\") 6 else 5, ord = 4, \n        equal.strata.knots = TRUE, typeGH = if (ind.noadapt) \"simple\" else \"adaptive\", \n        GHk = if (ncol(Z) < 3 && nrow(Z) < 2000) 15 else 9, \n        GKk = if (method == \"piecewise-PH-GH\" || length(Time) > nRisks*nT) 7 else 15, verbose = FALSE)\n    if (method == \"Cox-PH-GH\") {\n        con$only.EM <- TRUE\n        con$iter.EM <- 200\n        con$GHk <- if (ncol(Z) == 1) 15 else if (ncol(Z) == 2) 11 else 9\n    }\n    control <- c(control, list(...))\n    namC <- names(con)\n    con[(namc <- names(control))] <- control\n    if (con$typeGH != \"simple\" && !\"GHk\" %in% namc) {\n        con$GHk <- if (ncol(Z) <= 3 && nrow(Z) < 2000) 5 else 3\n    }\n    if (length(noNms <- namc[!namc %in% namC]) > 0) \n        warning(\"unknown names in 'control': \", paste(noNms, collapse = \", \"))\n    if (method == \"Cox-PH-GH\" && !con$only.EM)\n        stop(\"with method 'Cox-PH-GH' only the EM algorithm is used.\\n\")\n    if (method == \"Cox-PH-GH\" && any(!is.na(match(c(\"iter.qN\", \"optimizer\"), namc))))\n        warning(\"method 'Cox-PH-GH' uses only the EM algorithm.\\n\")\n    # extra design matrices for 'method = \"weibull-AFT-GH\"' and 'method = \"weibull-PH-GH\"'\n    # extra design matrices for 'method = \"spline-PH-GH\"' and 'method = \"spline-PH-Laplace\"'\n    if (method %in% c(\"weibull-AFT-GH\", \"weibull-PH-GH\", \"spline-PH-GH\", \"spline-PH-Laplace\")) {\n        wk <- gaussKronrod(con$GKk)$wk\n        sk <- gaussKronrod(con$GKk)$sk\n        if (LongFormat) {\n            Time0 <- survObject$y[, 1]\n            P <- (Time - Time0) / 2\n            P1 <- (Time + Time0) / 2\n            st <- outer(P, sk) + P1\n        } else {\n            P <- as.vector(Time)/2\n            st <- outer(P, sk + 1)\n        }\n        dimnames(st) <- names(P) <- NULL\n        id.GK <- rep(seq_along(Time), each = con$GKk)\n        data.id2 <- data.id[id.GK, , drop = FALSE]\n        data.id2[[timeVar]] <- pmax(c(t(st)) - lag, 0)\n        if (parameterization %in% c(\"value\", \"both\")) {\n            mfX <- model.frame(TermsX, data = data.id2)\n            mfZ <- model.frame(TermsZ, data = data.id2)\n            Xs <- model.matrix(formYx, mfX)\n            Zs <- model.matrix(formYz, mfZ)\n        }\n        if (parameterization %in% c(\"slope\", \"both\")) {\n            mfX.deriv <- model.frame(TermsX.deriv, data = data.id2)\n            mfZ.deriv <- model.frame(TermsZ.deriv, data = data.id2)\n            Xs.deriv <- model.matrix(derivForm$fixed, mfX.deriv)\n            Zs.deriv <- model.matrix(derivForm$random, mfZ.deriv)\n        }\n        Ws.intF.vl <- WintF.vl[id.GK, , drop = FALSE]\n        Ws.intF.sl <- WintF.sl[id.GK, , drop = FALSE]\n        x <- c(x, list(P = P, st = c(t(st)), wk = wk, Ws.intF.vl = Ws.intF.vl, \n            Ws.intF.sl = Ws.intF.sl))\n        x <- switch(parameterization,\n            \"value\" = c(x, list(Xs = Xs, Zs = Zs)),\n            \"slope\" = c(x, list(Xs.deriv = Xs.deriv, Zs.deriv = Zs.deriv)),\n            \"both\" = c(x, list(Xs.deriv = Xs.deriv, Zs.deriv = Zs.deriv, Xs = Xs, Zs = Zs)))\n        if (method == \"spline-PH-GH\" || method == \"spline-PH-Laplace\") {\n            strt <- if (is.null(survObject$strata)) gl(1, length(Time)) else survObject$strata\n            nstrt <- length(levels(strt))\n            split.Time <- split(Time, strt)\n            ind.t <- if (LongFormat) {\n                unlist(tapply(idT, idT, \n                    function (x) c(rep(FALSE, length(x) - 1), TRUE)))\n            } else {\n                rep(TRUE, length(Time))\n            }\n            kn <- if (con$equal.strata.knots) {\n                kk <- if (is.null(con$knots)) {\n                    pp <- seq(0, 1, length.out = con$lng.in.kn + 2)\n                    pp <- tail(head(pp, -1), -1)\n                    quantile(Time[ind.t], pp, names = FALSE)\n                } else {\n                    con$knots\n                }\n                kk <- kk[kk < max(Time)]\n                rr <- rep(list(sort(c(rep(range(Time, st), con$ord), kk))), nstrt)\n                names(rr) <- names(split.Time)\n                rr\n            } else {\n                spt <- if (length(Time) > nT & !CompRisk) \n                    mapply(function (x, y){\n                        x[unlist(tapply(y, y, \n                            function (z) c(rep(FALSE, length(z) - 1), TRUE)))]\n                    }, split.Time, split(idT, strt), SIMPLIFY = FALSE)\n                else split.Time\n                lapply(spt, function (t) {\n                    kk <- if (is.null(con$knots)) {\n                        pp <- seq(0, 1, length.out = con$lng.in.kn + 2)\n                        pp <- tail(head(pp, -1), -1)\n                        quantile(t, pp, names = FALSE)\n                    } else {\n                        con$knots\n                    }\n                    kk <- kk[kk < max(t)]\n                    sort(c(rep(range(Time, st), con$ord), kk))\n                })\n            }\n            con$knots <- kn\n            W2 <- mapply(function (k, t) splineDesign(k, t, ord = con$ord), kn, \n                            split.Time, SIMPLIFY = FALSE)\n            if (any(sapply(W2, colSums) == 0))\n                stop(\"\\nsome of the knots of the B-splines basis are set outside the range\",\n                    \"\\n   of the observed event times for one of the strata; refit the model\", \n                    \"\\n   setting the control argument 'equal.strata.knots' to FALSE.\")\n            W2 <- mapply(function (w2, ind) {\n                out <- matrix(0, length(Time), ncol(w2))\n                out[strt == ind, ] <- w2\n                out\n            }, W2, levels(strt), SIMPLIFY = FALSE)\n            W2 <- do.call(cbind, W2)\n            strt.s <- rep(strt, each = con$GKk)\n            split.Time <- split(c(t(st)), strt.s)\n            W2s <- mapply(function (k, t) splineDesign(k, t, ord = con$ord), \n                kn, split.Time, SIMPLIFY = FALSE)\n            W2s <- mapply(function (w2s, ind) {\n                out <- matrix(0, length(Time) * con$GKk, ncol(w2s))\n                out[strt.s == ind, ] <- w2s\n                out\n            }, W2s, levels(strt), SIMPLIFY = FALSE)\n            W2s <- do.call(cbind, W2s)\n            y <- c(y, list(strata = strt))\n            x <- c(x, list(W2 = W2, W2s = W2s))\n        }\n    }\n    # extra design matrices for 'method = \"piecewise-PH-GH\"'\n    if (method == \"piecewise-PH-GH\") {\n        wk <- gaussKronrod(con$GKk)$wk\n        sk <- gaussKronrod(con$GKk)$sk\n        nk <- length(sk)\n        if (is.null(con$knots) || !is.numeric(con$knots)) {\n            Q <- con$lng.in.kn + 1\n            qs <- if (con$ObsTimes.knots) {\n                unique(quantile(Time, seq(0, 1, len = Q + 1), \n                    names = FALSE)[-c(1, Q + 1)])\n            } else {\n                unique(quantile(Time[d == 1], seq(0, 1, len = Q - 1), \n                    names = FALSE))                \n            }\n            qs <- qs + 1e-06\n            if (max(qs) > max(Time))\n                qs[which.max(qs)] <- max(Time) - 1e-06\n            con$knots <- qs\n            qs <- c(0, qs, max(Time) + 1)\n            Q <- length(qs) - 1\n        } else {\n            qs <- c(0, sort(con$knots) + 1e-06, max(Time) + 1)\n            Q <- length(qs) - 1\n        }\n        ind <- findInterval(Time, qs, rightmost.closed = TRUE)\n        D <- matrix(0, length(ind), Q)\n        D[cbind(seq_along(ind), ind)] <- 1\n        D <- D * d\n        Tiq <- outer(Time, qs, pmin)\n        Lo <- Tiq[, 1:Q]\n        Up <- Tiq[, 2:(Q+1)]\n        T <- Up - Lo\n        P <- T / 2\n        P[P < con$tol3] <- as.numeric(NA)\n        P1 <- (Up + Lo) / 2\n        st <- matrix(0, nY, nk*Q)\n        skQ <- rep(sk, Q)\n        for (i in seq_len(nY)) {\n            st[i, ] <- rep(P[i, ], each = nk) * skQ + rep(P1[i, ], each = nk)\n        }\n        y <- c(y, list(ind.D = ind))\n        id.GK <- rep(seq_len(nY), rowSums(!is.na(st)))\n        P <- c(t(P))\n        data.id2 <- data.id[rep(seq_len(nY), each = nk*Q), ]\n        data.id2[[timeVar]] <- pmax(c(t(st)) - lag, 0)\n        data.id2 <- data.id2[!is.na(data.id2[[timeVar]]), ]\n        if (parameterization %in% c(\"value\", \"both\")) {\n            mfX <- model.frame(TermsX, data = data.id2)\n            mfZ <- model.frame(TermsZ, data = data.id2)\n            Xs <- model.matrix(formYx, mfX)\n            Zs <- model.matrix(formYz, mfZ)\n        }\n        if (parameterization %in% c(\"slope\", \"both\")) {\n            mfX.deriv <- model.frame(TermsX.deriv, data = data.id2)\n            mfZ.deriv <- model.frame(TermsZ.deriv, data = data.id2)\n            Xs.deriv <- model.matrix(derivForm$fixed, mfX.deriv)\n            Zs.deriv <- model.matrix(derivForm$random, mfZ.deriv)\n        }\n        Ws.intF.vl <- WintF.vl[id.GK, , drop = FALSE]\n        Ws.intF.sl <- WintF.sl[id.GK, , drop = FALSE]\n        x <- c(x, list(P = P[!is.na(P)], st = st[!is.na(st)], wk = wk, \n            id.GK = id.GK, Q = Q, Ws.intF.vl = Ws.intF.vl, Ws.intF.sl = Ws.intF.sl))\n        x <- switch(parameterization,\n            \"value\" = c(x, list(Xs = Xs, Zs = Zs)),\n            \"slope\" = c(x, list(Xs.deriv = Xs.deriv, Zs.deriv = Zs.deriv)),\n            \"both\" = c(x, list(Xs.deriv = Xs.deriv, \n                Zs.deriv = Zs.deriv, Xs = Xs, Zs = Zs))\n        )\n    }\n    # extra design matrices for 'method = \"Cox-PH-GH\"' with event times prior to observed time for the ith subject\n    if (method == \"Cox-PH-GH\") {\n        unqT <- sort(unique(Time[d == 1]))\n        times <- lapply(Time, function (t) unqT[t >= unqT])\n        ind.len <- sapply(times, length)\n        indT <- rep(1:nrow(data.id), ind.len)\n        data.id2 <- data.id[indT, ]\n        data.id2[timeVar] <- pmax(unlist(times, use.names = FALSE) - lag, 0)\n        if (parameterization %in% c(\"value\", \"both\")) {\n            mfX <- model.frame(TermsX, data = data.id2)\n            mfZ <- model.frame(TermsZ, data = data.id2)\n            Xtime2 <- model.matrix(formYx, mfX)\n            Ztime2 <- model.matrix(formYz, mfZ)\n        }\n        if (parameterization %in% c(\"slope\", \"both\")) {\n            mfX.deriv <- model.frame(TermsX.deriv, data = data.id2)\n            mfZ.deriv <- model.frame(TermsZ.deriv, data = data.id2)\n            Xtime2.deriv <- model.matrix(derivForm$fixed, mfX.deriv)\n            Ztime2.deriv <- model.matrix(derivForm$random, mfZ.deriv)\n        }\n        x <- c(x, list(indT = indT))\n        x <- switch(parameterization,\n            \"value\" = c(x, list(Xtime2 = Xtime2, Ztime2 = Ztime2)),\n            \"slope\" = c(x, list(Xtime2.deriv = Xtime2.deriv, \n                Ztime2.deriv = Ztime2.deriv)),\n            \"both\" = c(x, list(Xtime2.deriv = Xtime2.deriv, \n                Ztime2.deriv = Ztime2.deriv, Xtime2 = Xtime2, Ztime2 = Ztime2))\n        )\n    }\n    # initial values\n    VC <- lapply(pdMatrix(lmeObject$modelStruct$reStruct), \"*\", \n        lmeObject$sigma^2)[[1]]\n    if (con$typeGH != \"simple\") {\n        Vs <- vector(\"list\", nY)\n        inv.VC <- solve(VC)\n        for (i in 1:nY) {\n            Z.i <- Z[id == i, , drop = FALSE]\n            Vs[[i]] <- solve(crossprod(Z.i) / lmeObject$sigma^2 + inv.VC)        \n        }\n        con$inv.chol.VCs <- lapply(Vs, function (x) solve(chol(solve(x))))\n        con$det.inv.chol.VCs <- sapply(con$inv.chol.VCs, det)\n    }\n    con$inv.chol.VC <- solve(chol(solve(VC)))\n    con$det.inv.chol.VC <- det(con$inv.chol.VC)\n    con$ranef <- b\n    if (all(VC[upper.tri(VC)] == 0))\n        VC <- diag(VC)\n    init.surv <- initial.surv(Time, d, W, WintF.vl, WintF.sl, id, \n        times = data[[timeVar]], method, parameterization, long = long, \n        long.deriv = long.deriv, \n        extra = list(W2 = x$W2, control = con, ii = idT, strata = survObject$strata),\n        LongFormat = CompRisk | length(Time) > nT)\n    if (method == \"Cox-PH-GH\" && length(init.surv$lambda0) < length(unqT))\n        init.surv$lambda0 <- basehaz(survObject)$hazard\n    initial.values <- c(list(betas = fixef(lmeObject), sigma = lmeObject$sigma, D = VC), init.surv)\n    if (!is.null(init)) {\n        nams1 <- names(init)\n        nams2 <- names(initial.values)\n        if (!is.list(init) || length(noNms <- nams1[!nams1 %in% nams2])) {\n            warning(\"unknown names in 'init': \", paste(noNms, collapse = \", \"))\n        } else {\n            initial.values[nams1] <- init\n        }\n    }\n    # remove objects\n    rmObjs <- c(names(x), \"y.long\", \"mfX\", \"mfZ\", \"data.id2\")\n    rm(list = rmObjs); gc()\n    # joint model fit\n    out <- switch(method,\n        \"Cox-PH-GH\" = phGH.fit(x, y, id, initial.values, parameterization, derivForm, con),\n        \"weibull-AFT-GH\" = weibullAFTGH.fit(x, y, id, initial.values, scaleWB, parameterization, derivForm, con),\n        \"weibull-PH-GH\" = weibullPHGH.fit(x, y, id, initial.values, scaleWB, parameterization, derivForm, con),\n        \"piecewise-PH-GH\" = piecewisePHGH.fit(x, y, id, initial.values, parameterization, derivForm, con),\n        \"spline-PH-GH\" = splinePHGH.fit(x, y, id, initial.values, parameterization, derivForm, con),\n        \"ch-Laplace\" = chLaplace.fit(x, y, id, initial.values, b, parameterization, derivForm, con))\n    # check for problems with the Hessian at convergence\n    H <- out$Hessian\n    if (any(is.na(H) | !is.finite(H))) {\n        warning(\"infinite or missing values in Hessian at convergence.\\n\")\n    } else {\n        ev <- eigen(H, symmetric = TRUE, only.values = TRUE)$values\n        if (!all(ev >= -1e-06 * abs(ev[1]))) \n            warning(\"Hessian matrix at convergence is not positive definite.\\n\")\n    }\n    out$coefficients <- out$coefficients[!sapply(out$coefficients, is.null)]\n    out$x <- x\n    out$y <- y\n    out$times <- data[[timeVar]]\n    out$data <- data\n    out$data.id <- data.id\n    out$method <- method\n    out$termsYx <- TermsX\n    out$termsYz <- TermsZ\n    if (parameterization %in% c(\"slope\", \"both\")) {\n        out$termsYx.deriv <- TermsX.deriv\n        out$termsYz.deriv <- TermsZ.deriv\n    }\n    out$termsT <- survObject$terms\n    out$formYx <- formYx\n    out$formYz <- formYz\n    out$formT <- formT\n    out$timeVar <- timeVar\n    out$control <- con\n    out$parameterization <- parameterization\n    out$derivForm <- derivForm\n    out$interFact <- interFact\n    out$CompRisk <- CompRisk\n    out$LongFormat <- LongFormat\n    out$assignY <- attr(lmeObject$fixDF, \"assign\")[-1]\n    out$assignT <- survObject$assign\n    out$call <- cl\n    class(out) <- \"jointModel\"\n    out\n}\n",
    "created" : 1443616446753.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "252705365",
    "id" : "7AB74853",
    "lastKnownWriteTime" : 1461849543,
    "path" : "C:/Users/Dimitris/Documents/PackagesGitHub/JM/R/jointModel.R",
    "project_path" : "R/jointModel.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}